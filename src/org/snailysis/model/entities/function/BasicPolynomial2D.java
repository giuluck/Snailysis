package org.snailysis.model.entities.function;

import java.io.Serializable;
import java.util.Optional;
import java.util.function.UnaryOperator;

import org.jscience.mathematics.function.Polynomial;
import org.jscience.mathematics.function.Term;
import org.jscience.mathematics.number.Rational;
import org.snailysis.model.utilities.exceptions.ExceptionUtilities;

/**
 * Basic implementation of the interface Polynomial2D.
 */
public final class BasicPolynomial2D extends AbstractPolynomial2D implements Serializable {

    private static final long serialVersionUID = -2987951818519873755L;
    private static final String CLASSES_TEXT = "Incorrect Function Class";

    private final Polynomial<Rational> polynomial;

    /**
     * Package-private constructor to create Polynomial2D representing f(x) = ax^b.
     * 
     * @param coefficient
     *          the value of a
     * @param grade
     *          the value of b
     * @throws
     *          IllegalArgumentException if coefficient is zero
     *          IllegalArgumentException if grade is not positive
     */
    BasicPolynomial2D(final double coefficient, final int grade) {
        super();
        ExceptionUtilities.checkNotZero(coefficient, ZERO_TEXT);
        ExceptionUtilities.checkPositive(grade, NOT_POSITIVE_TEXT);
        this.polynomial = Polynomial.valueOf(Rational.ONE, VARIABLE)
                                    .pow(grade)
                                    .times(getRationalFromDouble(coefficient));
    }

    // private copy constructor
    private BasicPolynomial2D(final Polynomial<Rational> polynomial) {
        super();
        this.polynomial = polynomial.copy();
    }

    @Override
    public Function2D add(final Function2D gx) {
        if (Constant.class.isInstance(gx)) {
            return Optional.of(gx.evaluateAt(0))
                           .filter(t -> t != 0)
                           .map(BasicPolynomial2D::getRationalFromDouble)
                           .map(c -> performAndReturn(p -> p.plus(c)))
                           .orElse(new BasicPolynomial2D(polynomial.copy()));
        } else if (BasicPolynomial2D.class.isInstance(gx)) {
            return performAndReturn(p -> p.plus(((BasicPolynomial2D) gx).getPolynomialCopy()));
        } else {
            throw new IllegalArgumentException(CLASSES_TEXT);
        }
    }

    @Override
    public Function2D multiply(final Function2D gx) {
        if (Constant.class.isInstance(gx)) {
            return Optional.of(gx.evaluateAt(0))
                           .filter(t -> t != 0)
                           .map(BasicPolynomial2D::getRationalFromDouble)
                           .map(k -> performAndReturn(p -> p.times(k)))
                           .orElse(new Constant(0));
        } else if (BasicPolynomial2D.class.isInstance(gx)) {
            return performAndReturn(p -> p.times(((BasicPolynomial2D) gx).getPolynomialCopy()));
        } else {
            throw new IllegalArgumentException(CLASSES_TEXT);
        }
    }

    @Override
    public Function2D compose(final Function2D gx) {
        if (Constant.class.isInstance(gx)) {
            return new Constant(this.evaluateAt(gx.evaluateAt(0))); // f(k) = h
        } else if (BasicPolynomial2D.class.isInstance(gx)) {
            return performAndReturn(p -> p.compose(((BasicPolynomial2D) gx).getPolynomialCopy()));
        } else {
            throw new IllegalArgumentException(CLASSES_TEXT);
        }
    }

    @Override
    public Function2D differentiate() {
        return performAndReturn(t -> t.differentiate(VARIABLE));
    }

    @Override
    public Function2D integrate() {
        return performAndReturn(t -> t.integrate(VARIABLE));
    }

    @Override
    public double evaluateAt(final double x) {
        return polynomial.evaluate(getRationalFromDouble(x)).doubleValue();
    }

    @Override
    public String toString() {
        return polynomialToString(polynomial);
    }

    /* AUTO-GENERATED by Eclipse */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((polynomial == null) ? 0 : polynomial.hashCode());
        return result;
    }

    @Override
    public boolean equals(final Object obj) {
        // I compare the strings representations as the polynomial.equals() method doesn't work properly
        return Optional.ofNullable(obj)
                       .filter(o -> getClass().equals(o.getClass()))
                       .map(o -> (BasicPolynomial2D) o)
                       .filter(o -> this.toString().equals(o.toString()))
                       .isPresent();
    }

    /**
     * Protected method to access the polynomial function inside the class.
     * 
     * @return
     *          a copy of the polynomial function.
     */
    protected Polynomial<Rational> getPolynomialCopy() {
        return polynomial.copy();
    }

    // performs an operation over the Polynomial<Rational> function and return the result
    private Function2D performAndReturn(final UnaryOperator<Polynomial<Rational>> operator) {
        final Polynomial<Rational> result = operator.apply(polynomial.copy());
        if (result.getVariables().isEmpty()) {
            return new Constant(result.getCoefficient(Term.ONE).doubleValue());
        } else {
            return new BasicPolynomial2D(result);
        }
    }
}
